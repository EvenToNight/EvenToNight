name: Make New Release and Build & Push Docker Images
on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  JAVA_VERSION: 21
  NODE_VERSION: 22.19

jobs:
  release:
    concurrency:
      group: release-${{ github.head_ref || github.ref_name || github.run_id }}
      cancel-in-progress: false
    permissions:
      contents: write
      pull-requests: write
      issues: write
    runs-on: ubuntu-22.04
    outputs:
      release_done: ${{ steps.evaluate_release.outputs.release }}
    steps:
      - name: Generate a token
        id: generate-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.SEMANTIC_RELEASE_APP_ID }}
          private-key: ${{ secrets.SEMANTIC_RELEASE_APP_KEY }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ steps.generate-token.outputs.token }}

      - name: Fetch all tags
        run: git fetch --tags

      - name: Set up JDK ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: "temurin"

      - name: Set up Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        run: npm install

      - name: Run semantic-release
        id: semantic-release
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ steps.generate-token.outputs.token }}
        run: |
          set -e
          echo "Running semantic-release‚Ä¶"
          before_tags=$(git tag)
          npx semantic-release || true
          after_tags=$(git tag)
          
          # Detect if new tag appeared
          new_tag=$(comm -13 <(echo "$before_tags" | sort) <(echo "$after_tags" | sort) | tail -n 1 || true)

          if [ -n "$new_tag" ]; then
            echo "‚úÖ Semantic-release created a new tag: $new_tag"
            echo "release_done=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è No new release tag created"
            echo "release_done=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Detect changes under /services
        id: detect_services
        if : ${{ steps.semantic-release.outputs.release_done == 'false' }}
        run: |
          echo "üîç Checking for changes under services/..."
          CHANGED=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep '^services/' || true)
          if [ -n "$CHANGED" ]; then
            echo "‚úÖ Detected changes under /services:"
            echo "services_changed=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No changes detected under /services"
            echo "services_changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Detect changes under /infrastructure
        id: detect_infrastructure
        if : ${{ steps.semantic-release.outputs.release_done == 'false' && steps.detect_services.outputs.services_changed == 'false' }}
        run: |
          echo "üîç Checking for changes under infrastructure/..."
          CHANGED=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep '^infrastructure/' || true)
          if [ -n "$CHANGED" ]; then
            echo "‚úÖ Detected changes under /infrastructure:"
            echo "infrastructure_changed=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No changes detected under /infrastructure"
            echo "infrastructure_changed=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Evaluate release
        id: evaluate_release
        run: |
          pre_release=$([[ "${{ steps.semantic-release.outputs.release_done }}" == "false" && ( "${{ steps.detect_services.outputs.services_changed }}" == "true" || "${{ steps.detect_infrastructure.outputs.infrastructure_changed }}" == "true" ) ]] && echo "true" || echo "false")
          release=$([[ "${{ steps.semantic-release.outputs.release_done }}" == "true" || "$pre_release" == "true" ]] && echo "true" || echo "false")

          echo "pre_release=$pre_release" >> $GITHUB_OUTPUT
          echo "release=$release" >> $GITHUB_OUTPUT

      - name: Create dev pre-release
        if: ${{ steps.evaluate_release.outputs.pre_release == 'true' }}
        env:
          GITHUB_TOKEN: ${{ steps.generate-token.outputs.token }}
        run: |
          set -e
          echo "‚öôÔ∏è No relevant commits ‚Äî creating dev pre-release"

          last_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v1.0.0")
          echo "Last tag: $last_tag"

          core_version=$(echo "$last_tag" | sed -E 's/^v([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
          IFS=. read -r major minor patch <<< "$core_version"

          if [[ "$last_tag" =~ -dev\.([0-9]+)$ ]]; then
            new_tag="v${major}.${minor}.${patch}-dev.$((${BASH_REMATCH[1]}+1))"
          else
            new_tag="v${major}.${minor}.$((patch+1))-dev.1"
          fi

          echo "New tag: $new_tag"
          git tag "$new_tag" && git push origin "$new_tag"
          gh release create "$new_tag" --title "$new_tag" --notes "Automated pre-release" --prerelease
          echo "‚úÖ Created $new_tag"

  find-modified-dockerfiles:
    needs: release
    if: ${{ needs.release.outputs.release_done == 'true'}}
    runs-on: ubuntu-22.04
    outputs:
      dockerfiles: ${{ steps.find-dockerfiles.outputs.dockerfiles }}
      release_tag: ${{ steps.get_tag.outputs.release }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Find all modified directories with Dockerfiles
        id: find-dockerfiles
        run: |
          dockerfiles=$(./scripts/findDockerfiles.sh "${{ github.event.before }}" "${{ github.sha }}")
          echo "dockerfiles=$dockerfiles" >> $GITHUB_OUTPUT

      - name: Get latest GitHub Release tag
        id: get_tag
        uses: pozetroninc/github-action-get-latest-release@v0.8.0
        with:
          repository: ${{ github.repository }}

  build-and-push-docker-images:
    needs: find-modified-dockerfiles
    if: ${{ needs.find-modified-dockerfiles.outputs.dockerfiles != '[]' }}
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write
    strategy:
      matrix:
        dockerfile: ${{ fromJson(needs.find-modified-dockerfiles.outputs.dockerfiles) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        run: |
          repo_lower=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          release_tag="${{ needs.find-modified-dockerfiles.outputs.release_tag }}"
          echo "üè∑Ô∏è Using release tag: $release_tag"

          dockerfile="${{ matrix.dockerfile }}"
          dockerfile_name=$(basename "$dockerfile")
          parent_dir=$(basename "$(dirname "$dockerfile")")

          if [ "$dockerfile_name" = "Dockerfile" ]; then
              service_name="$parent_dir"
          else
              suffix="${dockerfile_name#Dockerfile}"
              service_name="${parent_dir}${suffix}"
          fi

          image_base="ghcr.io/${repo_lower}/${service_name}"
          image_latest="${image_base}:latest"
          image_release="${image_base}:${release_tag}"

          echo "üöÄ Building image for $service_name"
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            --tag "$image_latest" \
            --tag "$image_release" \
            --file "$dockerfile" \
            --push \
            .

  dev-deploy:
    needs: build-and-push-docker-images
    name: Run SSH command
    runs-on: ubuntu-22.04
    steps:
      - name: Connect and run command on remote server
        uses: and-fm/cloudflared-ssh-action@v3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USERNAME }}
          private_key_filename: ${{ secrets.SSH_PRIVATE_KEY_FILENAME }}
          private_key_value: ${{ secrets.SSH_PRIVATE_KEY_VALUE }}
          port: ${{ secrets.SSH_PORT }}
          service_token_id: ${{ secrets.SERVICE_TOKEN_ID }}
          service_token_secret: ${{ secrets.SERVICE_TOKEN_SECRET }}
          commands: |
            set -e

            REPO_URL="https://github.com/EvenToNight/EvenToNight.git"
            DEST_DIR="EvenToNight-production"

            # pull or clone fresh
            if ! git -C "$DEST_DIR" pull; then
              echo "Pull failed..."
              # Backup .env if exists
              if [ -f "$DEST_DIR/.env" ]; then
                echo "Backing up .env..."
                cp "$DEST_DIR/.env" ".env"
                echo ".env backed up."
              fi
              if [ -d "$DEST_DIR" ]; then
                echo "Removing existing project directory..."
                rm -rf "$DEST_DIR"
                echo "Project directory removed."
              fi
              echo "Cloning fresh repository..."
              git clone "$REPO_URL" "$DEST_DIR"
              # Restore .env
              if [ -f ".env" ]; then
                echo "Restoring .env..."
                mv ".env" "$DEST_DIR/.env"
                echo ".env restored."
              fi
            fi
          
            cd "$DEST_DIR"
            # check environment
            ./scripts/updateLocalEnv.sh
            ./scripts/checkEnvSetup.sh

            # update .env
            perl -pi -e 's/^HOST=.*/HOST=eventonight.site/' .env

            # deploy
            ./scripts/composeApplication.sh pull
            ./scripts/composeApplication.sh up -d --remove-orphans --wait
            docker restart eventonight-traefik-1