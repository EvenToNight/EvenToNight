/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * To learn more about Gradle by exploring our Samples at https://docs.gradle.org/8.4/samples
 */
import AnsiColors.GREEN
import AnsiColors.RED
import AnsiColors.RESET

group = "org.eventonight.eventonight"
version = "1.0-SNAPSHOT"

plugins {
    base
}

allprojects {
    repositories {
        mavenCentral()
    }
}

tasks.register<ExecTask>("updateEnvFile") {
    description = "Update the .env file from the .env.template and check if some values are missing."
    group = "setup"
    bashCommands("./scripts/updateLocalEnv.sh")
}

tasks.register<ExecTask>("checkEnvSetup") {
    description = "Check if the .env file and .env.template file are properly set up."
    group = "setup"
    bashCommand("./scripts/checkEnvSetup.sh")
}

tasks.named("checkEnvSetup") {
    mustRunAfter("updateEnvFile")
}

tasks.register("updateAndCheckEnvSetup") {
    description = "Update the .env file and check if it is properly set up."
    group = "setup"
    dependsOn("updateEnvFile", "checkEnvSetup")    
}

gradle.projectsEvaluated {
    tasks.configureEach {
        if (group == "docker") {
            dependsOn(tasks.named("updateEnvFile"))
        }
    }
}

tasks.register<ExecTask>("teardownTestEnvironment") {
    description = "Tear down the Docker test environment."
    group = "docker"
    bashCommands(DockerCommands.TEARDOWN_TEST_ENVIRONMENT)
}

tasks.register<ExecTask>("teardownDevEnvironment") {
    description = "Tear down the Docker development environment."
    group = "docker"
    bashCommand(DockerCommands.TEARDOWN_DEV_ENVIRONMENT)
}

tasks.register<ExecTask>("teardownApplicationEnvironment") {
    description = "Tear down the Docker application environment."
    group = "docker"
    bashCommands(DockerCommands.TEARDOWN_APPLICATION_ENVIRONMENT)
}

tasks.register<ExecTask>("teardownKeycloak") {
    description = "Tear down Keycloak"
    group = "docker"
    bashCommands(DockerCommands.TEARDOWN_KEYCLOAK)
}

tasks.register<ExecTask>("teardownMediaService") {
    description = "Tear down the Media Service."
    group = "docker"
    bashCommands(DockerCommands.TEARDOWN_MEDIA)
}

tasks.register<ExecTask>("teardownUsersEnvironment") {
    description = "Tear down the users environment."
    group = "docker"
    dependsOn("teardownDevEnvironment")
    dependsOn("teardownKeycloak")
    dependsOn("teardownMediaService")
}

tasks.register<ExecTask>("teardownFrontendEnvironment") {
    description = "Tear down the Docker frontend environment."
    group = "docker"
    dependsOn("stopStripeWebHooksListener")
    bashCommands(DockerCommands.TEARDOWN_FRONTEND_ENVIRONMENT)
}

tasks.register<ExecTask>("teardownPaymentsEnvironment") {
    description = "Tear down the Docker payments environment."
    group = "docker"
    dependsOn("stopStripeWebHooksListener")
    dependsOn("teardownDevEnvironment")
    bashCommands(DockerCommands.TEARDOWN_PAYMENTS_ENVIRONMENT)
}

tasks.register<ExecTask>("stopStripeWebHooksListener") {
    group = "docker"
    description = "Stops the Stripe WebHooks listener."
    
    bashCommands("""
        echo 'ðŸ›‘ Stopping Stripe Webhook listener...' && \
        pkill -f "stripe listen" || true && \
        echo 'âœ… Process stopped'
    """)
}

tasks.register<ExecTask>("setupTestEnvironment") {
    description = "Set up the Docker test environment."
    group = "docker"
    bashCommands(DockerCommands.TEARDOWN_TEST_ENVIRONMENT).onFailure { code ->
        println("${RED}Teardown failed with exit code ${code}.${RESET}")
    }
    println("ðŸ’¬ Setting up the test environment...")
    bashCommands(DockerCommands.SETUP_TEST_ENVIRONMENT)
}

tasks.register<ExecTask>("setupDevEnvironment") {
    description = "Set up the Docker development environment."
    group = "docker"
    bashCommands(DockerCommands.TEARDOWN_DEV_ENVIRONMENT).onFailure { code ->
        println("${RED}Teardown failed with exit code ${code}.${RESET}")
    }
    println("ðŸ’¬ Setting up the development environment...")
    bashCommands(DockerCommands.SETUP_DEV_ENVIRONMENT)
}

tasks.register<ExecTask>("setupApplicationEnvironment") {
    description = "Set up the Docker application environment."
    group = "docker"
    bashCommands(DockerCommands.TEARDOWN_APPLICATION_ENVIRONMENT).onFailure { code ->
        println("${RED}Teardown failed with exit code ${code}.${RESET}")
    }
    println("ðŸ’¬ Setting up the application environment...")
    bashCommands(DockerCommands.SETUP_APPLICATION_ENVIRONMENT)
}

tasks.register<ExecTask>("setupKeycloak") {
    description = "Set up Keycloak"
    group = "docker"
    bashCommands(DockerCommands.TEARDOWN_KEYCLOAK).onFailure { code ->
        println("${RED}Teardown failed with exit code ${code}.${RESET}")
    }
    println("Setting up Keycloak...")
    bashCommands(DockerCommands.SETUP_KEYCLOAK)
}

tasks.register<ExecTask>("setupMediaService") {
    description = "Set up the Media Service."
    group = "docker"
    bashCommands(DockerCommands.TEARDOWN_MEDIA).onFailure { code ->
        println("${RED}Teardown failed with exit code ${code}.${RESET}")
    }
    println("ðŸ’¬ Setting up the Media Service...")
    bashCommands(DockerCommands.SETUP_MEDIA_SERVICE)
}

tasks.register<ExecTask>("setupUsersEnvironment") {
    description = "Set up the users environment."
    group = "docker"
    dependsOn("setupDevEnvironment")
    dependsOn("setupKeycloak")
    dependsOn("setupMediaService")
}

tasks.register<ExecTask>("setupFrontendEnvironment") {
    description = "Set up the Docker frontend environment."
    group = "docker"
    dependsOn("setupStripeWebHooksListener")
    bashCommands(DockerCommands.TEARDOWN_FRONTEND_ENVIRONMENT).onFailure { code ->
        println("${RED}Teardown failed with exit code ${code}.${RESET}")
    }
    println("ðŸ’¬ Setting up the frontend environment...")
    bashCommands(DockerCommands.SETUP_FRONTEND_ENVIRONMENT)
}

tasks.register<ExecTask>("setupPaymentsEnvironment") {
    description = "Set up the Docker payments environment."
    group = "docker"
    dependsOn("setupStripeWebHooksListener")
    bashCommands(DockerCommands.TEARDOWN_PAYMENTS_ENVIRONMENT).onFailure { code ->
        println("${RED}Teardown failed with exit code ${code}.${RESET}")
    }
    println("ðŸ’¬ Setting up the payments environment...")
    bashCommands(DockerCommands.SETUP_DEV_ENVIRONMENT + " --scale rabbitmq=0")
    bashCommands(DockerCommands.SETUP_PAYMENTS_ENVIRONMENT)
}

tasks.register<ExecTask>("setupStripeWebHooksListener") {
    description = "Set up the Stripe WebHooks listener."
    group = "docker"
    dependsOn("stopStripeWebHooksListener")
    bashCommands("""
        sed -i '' '/^STRIPE_WEBHOOK_SECRET=/d' .env && \
        (nohup ./services/payments/scripts/local-webooks.sh > webhook.log 2>&1 &) && \
        echo 'â³ Waiting for webhook listener...' && \
        until grep -q 'STRIPE_WEBHOOK_SECRET=whsec_' .env 2>/dev/null; do sleep 1; done && \
        echo 'âœ… Webhook listener ready'
    """)
}

tasks.register("saveStagedFiles") {
    description = "Saves the list of currently staged files to re-stage them later."
    group = "git"
    notCompatibleWithConfigurationCache("Saving staged files is not compatible with configuration cache")
    doLast {
        val stagedFiles = ProcessBuilder("git", "diff", "--name-only", "--cached", "--diff-filter=d")
            .redirectErrorStream(true)
            .start()
            .inputStream.bufferedReader().readLines()
            .map { it.trim() }
            .filter { it.isNotEmpty() }
        extensions.add("stagedFilesList", stagedFiles)
        println("ðŸ’¾ Saved ${stagedFiles.size} staged file(s)")
    }

}

tasks.register("updateStagedFiles") {
    description = "Re-stages the files that were previously saved."
    group = "git"
    notCompatibleWithConfigurationCache("Updating staged files is not compatible with configuration cache")
    dependsOn("saveStagedFiles")
    doLast {
        val stagedFiles = tasks.named("saveStagedFiles").get().extensions["stagedFilesList"]
            .let { it as? List<*> }
            ?.filterIsInstance<String>()
            ?: emptyList()
        stagedFiles.forEach { file ->
            exec { commandLine("git", "add", file) }
        }
        println("âœ… Re-staged ${stagedFiles.size} file(s) after formatting.")
    }
}

tasks.register("formatAndLintPreCommit") {
    description = "Formats and lints the codebase."
    group = "git"
    dependsOn("saveStagedFiles")

    val subPreCommitTasks = subprojects.mapNotNull { proj ->
        proj.tasks.findByName("formatAndLintPreCommit")
    }
    subPreCommitTasks.forEach { it.mustRunAfter(rootProject.tasks.named("saveStagedFiles")) }
    dependsOn(subPreCommitTasks)

    finalizedBy("updateStagedFiles")
}

tasks.register("runCoverage") {
    description = "Run coverage analysis for all services"
    group = "verification"
    
    val coverageTasks = subprojects.mapNotNull { proj ->
        proj.tasks.findByName("runCoverage")
    }
    dependsOn(coverageTasks)
}