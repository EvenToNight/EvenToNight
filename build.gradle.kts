/*
 * This file was generated by the Gradle 'init' task.
 *
 * This is a general purpose Gradle build.
 * To learn more about Gradle by exploring our Samples at https://docs.gradle.org/8.4/samples
 */
import AnsiColors.GREEN
import AnsiColors.RED
import AnsiColors.RESET

group = "org.eventonight.eventonight"
version = "1.0-SNAPSHOT"

plugins {
    base
}

allprojects {
    repositories {
        mavenCentral()
    }
}

tasks.named("build") {
    dependsOn("updateAndCheckEnvFile")
}

tasks.register<ExecTask>("updateAndCheckEnvFile") {
    description = "Update the .env file from the .env.template and check if some values are missing."
    group = "setup"
    bashCommands("./scripts/updateLocalEnv.sh", "./scripts/checkEnvSetup.sh")
}

gradle.projectsEvaluated {
    tasks.configureEach {
        if (group == "docker") {
            dependsOn(tasks.named("updateAndCheckEnvFile"))
        }
    }
}

tasks.register<ExecTask>("teardownTestEnvironment") {
    description = "Tear down the Docker test environment."
    group = "docker"
    bashCommands(DockerCommands.TEARDOWN_TEST_ENVIRONMENT)
}

tasks.register<ExecTask>("teardownDevEnvironment") {
    description = "Tear down the Docker development environment."
    group = "docker"
    bashCommand(DockerCommands.TEARDOWN_DEV_ENVIRONMENT)
}

tasks.register<ExecTask>("teardownApplicationEnvironment") {
    description = "Tear down the Docker application environment."
    group = "docker"
    bashCommands(DockerCommands.TEARDOWN_APPLICATION_ENVIRONMENT)
}

tasks.register<ExecTask>("setupTestEnvironment") {
    description = "Set up the Docker test environment."
    group = "docker"
    bashCommands(DockerCommands.TEARDOWN_TEST_ENVIRONMENT).onFailure { code ->
        println("${RED}Teardown failed with exit code ${code}.${RESET}")
    }
    println("ðŸ’¬ Setting up the test environment...")
    bashCommands(DockerCommands.SETUP_TEST_ENVIRONMENT)
}

tasks.register<ExecTask>("setupDevEnvironment") {
    description = "Set up the Docker development environment."
    group = "docker"
    bashCommands(DockerCommands.TEARDOWN_DEV_ENVIRONMENT).onFailure { code ->
        println("${RED}Teardown failed with exit code ${code}.${RESET}")
    }
    println("ðŸ’¬ Setting up the development environment...")
    bashCommands(DockerCommands.SETUP_DEV_ENVIRONMENT)
}

tasks.register<ExecTask>("setupApplicationEnvironment") {
    description = "Set up the Docker application environment."
    group = "docker"
    bashCommands(DockerCommands.TEARDOWN_APPLICATION_ENVIRONMENT).onFailure { code ->
        println("${RED}Teardown failed with exit code ${code}.${RESET}")
    }
    println("ðŸ’¬ Setting up the application environment...")
    bashCommands(DockerCommands.SETUP_APPLICATION_ENVIRONMENT)
}

tasks.register("saveStagedFiles") {
    description = "Saves the list of currently staged files to re-stage them later."
    group = "git"
    notCompatibleWithConfigurationCache("Saving staged files is not compatible with configuration cache")
    val stagedFiles = mutableListOf<String>()
    doLast {
        val output = ProcessBuilder("git", "diff", "--name-only", "--cached")
            .redirectErrorStream(true)
            .start()
            .inputStream.bufferedReader().readLines()
            .map { it.trim() }
            .filter { it.isNotEmpty() }
        stagedFiles.addAll(output)
        println("ðŸ’¾ Saved ${stagedFiles.size} staged file(s)")
    }
    extensions.add("stagedFilesList", stagedFiles)
}

tasks.register("updateStagedFiles") {
    description = "Re-stages the files that were previously saved."
    group = "git"
    notCompatibleWithConfigurationCache("Updating staged files is not compatible with configuration cache")
    dependsOn("saveStagedFiles")
    doLast {
        val stagedFiles = (tasks.named("saveStagedFiles").get().extensions["stagedFilesList"] as? List<String>) ?: emptyList()
        stagedFiles.forEach { file ->
            exec { commandLine("git", "add", file) }
        }
        println("âœ… Re-staged ${stagedFiles.size} file(s) after formatting.")
    }
}

tasks.register("formatAndLintPreCommit") {
    description = "Formats and lints the codebase."
    group = "git"
    dependsOn("saveStagedFiles")

    val subPreCommitTasks = subprojects.mapNotNull { proj ->
        proj.tasks.findByName("formatAndLintPreCommit")
    }
    subPreCommitTasks.forEach { it.mustRunAfter(rootProject.tasks.named("saveStagedFiles")) }
    dependsOn(subPreCommitTasks)

    finalizedBy("updateStagedFiles")
 }
